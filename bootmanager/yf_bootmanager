#! /bin/sh
# vim: set tabstop=4 syntax=sh :
# SPDX-License-Identifier: GPL-2.0-or-later
#######################################################################################################
#                                                                                                     #
# detection and display of properties for the two different installed OS versions on FRITZ!Box        #
# devices with a 'mirrored' system and switch to the alternative one, if requested by caller          #
#                                                                                                     #
###################################################################################################VER#
#                                                                                                     #
# yf_bootmanager, version 0.7.0 (up to version 0.6.x it was called 'gui_bootmanager')                 #
#                                                                                                     #
# This script is a part of the YourFritz project from https://github.com/PeterPawn/YourFritz.         #
#                                                                                                     #
###################################################################################################CPY#
#                                                                                                     #
# Copyright (C) 2014-2020 P.Haemmerlein (peterpawn@yourfritz.de)                                      #
#                                                                                                     #
###################################################################################################LIC#
#                                                                                                     #
# This project is free software, you can redistribute it and/or modify it under the terms of the GNU  #
# General Public License as published by the Free Software Foundation; either version 2 of the        #
# License, or (at your option) any later version.                                                     #
#                                                                                                     #
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without   #
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU       #
# General Public License under http://www.gnu.org/licenses/gpl-2.0.html for more details.             #
#                                                                                                     #
#######################################################################################################
#                                                                                                     #
# "FRITZ!Box" and "FRITZ!" are registered word marks and "AVM" is a registered word and figurative    #
# mark of:                                                                                            #
#                                                                                                     #
# AVM Computersysteme Vertriebs GmbH, 10559, Berlin, DE.                                              #
#                                                                                                     #
#######################################################################################################
#                                                                                                     #
# This script implements all actions necessary to detect and collect the properties of the systems in #
# the two different partition sets, that are used by devices with a 'mirrored OS' (by AVM). If the    #
# device supports this 'dual-boot' feature, the script provides data to the caller about available    #
# systems and their properties and allows to switch to the alternative one on next restart, if this   #
# is requested by the user. If there's any usable (and known) option to change the 'firmware_version' #
# value for the next start (with alternative or currently running system), this may be set at the     #
# same time.                                                                                          #
#                                                                                                     #
# It should support any VR9-, AR10-, IPQ40x9- or GRX5-based device as well as devices with Puma6/7    #
# chipsets (Puma7 SoCs are still untested and solely based on already published script code by AVM).  #
#                                                                                                     #
# With update to 0.7.0, the file was renamed to 'yf_bootmanager' and the generation of static HTML    #
# code for versions before FRITZ!OS 7 has been out-sourced.                                           #
#                                                                                                     #
# It supports now three different approaches to change the 'branding' value (from 'firmware_version'  #
# item in the 'urlader environment'), even if the bootloader resets a user-changed value at each new  #
# start to the 'native' one from its data after finalization by manufacturer.                         #
#                                                                                                     #
# There are two (additional) options to set the value dynamically (using 'yf_custom_environment' or   #
# using 'yf_change_oem') and this script supports both of them, in the specified order. At the same   #
# time, a 'fixed branding' (from the 'export OEM' statement by AVM) is taken in to account, because   #
# this will overwrite changes by any other approach. As last resort the script tries to detect,       #
# whether the present bootloader code will always reset the value or not. If any chance to modify the #
# value was found, a selection of the contained 'branding values' is provided and one of these values #
# may be used as the third parameter in a 'switch_to' call (after 'running' or 'alternative' as the   #
# second one).                                                                                        #
#                                                                                                     #
# There are five operations supported as first argument (at least one parameter is always required):  #
#                                                                                                     #
# is_supported - returns true (exit code 0) or false (exit code 1), if the device doesn't support the #
#                dual-boot selection                                                                  #
# is_blocked   - check the used semaphore file, if there's already a running instance                 #
# switch_to    - switches to the 'running' or 'alternative' system (2nd parameter) and (optionally)   #
#                sets the OEM name to the 3rd parameter (it has to be one from the cached data)       #
# get_values   - provide a list of relevant values for implementers of other interfaces, without the  #
#                needs to implement the full logic once again; if the second parameter is 'nocache',  #
#                an existing cache file (where those data is stored otherwise - ready for output on   #
#                next call) gets ignored                                                              #
# debug        - this operation is intended only for diagnose, it shows some settings and their       #
#                current values on STDOUT to provide information about the current system             #
# clear_cache  - remove saved data from an earlier 'get_values' call without 'nocache' argument       #
#                                                                                                     #
# The script tries to detect the framework (if any), which was used to modify the original firmware.  #
# To find this, it checks for the YourFritz version file, the Freetz version file (it adds an option  #
# for Freetz-NG, too) and the "modfs" version file in this order and the first file found is assumed  #
# to be a mark of the used framework.                                                                 #
#                                                                                                     #
#######################################################################################################
#                                                                                                     #
# constants                                                                                           #
#                                                                                                     #
#######################################################################################################
#                                                                                                     #
# required shell commands                                                                             #
#                                                                                                     #
#######################################################################################################
readonly required_commands="sed expr cat mkdir rm rmdir cmp dd date mount umount base64 stat"
#######################################################################################################
#                                                                                                     #
# common values                                                                                       #
#                                                                                                     #
#######################################################################################################
readonly project_prefix="yf"
readonly project_name="${project_prefix}_bootmanager"
readonly project_version="0.7.0"
readonly tmpdir="${TMPDIR:-/var/tmp}"
readonly rundir="${RUNDIR:-/var/run}"
readonly data_cache_file="$tmpdir/$project_name.data"
readonly boot_cache_file="$tmpdir/$project_name.boot"
readonly proc="${YF_BOOTMANAGER_BASEDIR}/proc"
readonly dev="${YF_BOOTMANAGER_BASEDIR}/dev"
readonly sysfs="${YF_BOOTMANAGER_BASEDIR}/sys"
readonly search_path=${YF_BOOTMANAGER_BASEDIR}/sbin:${YF_BOOTMANAGER_BASEDIR}/usr/sbin:${YF_BOOTMANAGER_BASEDIR}/bin:${YF_BOOTMANAGER_BASEDIR}/usr/bin
readonly orcus="$dev/null"
readonly urlader_environment="$proc/sys/urlader/environment"
readonly system_select_name="linux_fs_start"
readonly active_name="active"
readonly inactive_name="inactive"
readonly branding_name="firmware_version"
readonly mtd_prefix="mtd"
readonly mtdblock_prefix="$dev/mtdblock"
readonly mtdblock_mask="${mtdblock_prefix}%u"
readonly proc_mtd="$proc/$mtd_prefix"
readonly proc_devices="$proc/devices"
readonly proc_cpuinfo="$proc/cpuinfo"
readonly proc_mountinfo="$proc/self/mountinfo"
readonly kernel_name="kernel"
readonly filesystem_name="filesystem"
readonly reserved_prefix="reserved"
readonly alt_root_mount_name="alt_root"
readonly defaults_dir="etc/default.\$PRODUKT"
readonly sysfs_block_dir="$sysfs/block"
readonly loop_driver_name="loop"
readonly backing_file_name="backing_file"
readonly avm_rcconf="etc/init.d/rc.conf"
readonly semafile="$rundir/$project_name.sem"
readonly fdt_chosen="$proc/device-tree/chosen"
#######################################################################################################
#                                                                                                     #
# various sources for version numbers                                                                 #
#                                                                                                     #
#######################################################################################################
readonly yourfritz_version_file="etc/.yourfritz_version"
readonly freetz_version_file="etc/.freetz-version"
readonly freetz_ng_version_file="etc/.freetz-ng-version"
readonly modfs_version_file="etc/.modfs_version"
readonly avm_version_file_old="etc/version"
readonly avm_version_file_old_prefix="FIRMWARE_"
readonly avm_version_file="etc/init.d/rc.conf"
readonly avm_version_file_prefix="CONFIG_"
readonly avm_version_main_components="VERSION SUBVERSION"
readonly avm_version_major_name="CONFIG_VERSION_MAJOR"
readonly avm_version_date="DATE"
readonly avm_product_name="CONFIG_PRODUKT"
readonly version_files="'$yourfritz_version_file' '$freetz_version_file' '$freetz_ng_version_file' '$modfs_version_file'"
readonly modified_by="YourFritz Freetz Freetz-NG modfs -"
#######################################################################################################
#                                                                                                     #
# GRX5, VR9 and IPQ4019 common settings                                                               #
#                                                                                                     #
#######################################################################################################
readonly mtd_filesystem_name_active="${filesystem_name}"
readonly mtd_filesystem_name_inactive="${reserved_prefix}-${filesystem_name}"
readonly mtd_kernel_name_active="${kernel_name}"
readonly mtd_kernel_name_inactive="${reserved_prefix}-${kernel_name}"
#######################################################################################################
#                                                                                                     #
# IPQ4019 specific settings (IPQ4018-based devices should use SPI flash with a single OS)             #
#                                                                                                     #
#######################################################################################################
readonly ipq4019_cpuinfo_check="s|^model name[ \t]*: ARMv7 Processor rev 5 (v7l)\$|IPQ4019|p;tq;b;:q q"
#######################################################################################################
#                                                                                                     #
# VR9 specific settings                                                                               #
#                                                                                                     #
#######################################################################################################
readonly wrapper_mount_name="wrapper"
readonly wrapper_mount_prefix="mount:"
readonly vr9_wrapper_dir="/wrapper"
readonly vr9_rootfs_name="/filesystem_core.squashfs"
readonly vr9_image_source_active="${vr9_wrapper_dir}${vr9_rootfs_name}"
readonly vr9_image_source_inactive="$wrapper_mount_prefix%s:${vr9_rootfs_name}"
########################################################################################################
#                                                                                                     #
# Puma6 / Puma7 specific settings                                                                     #
#                                                                                                     #
#######################################################################################################
readonly puma_helper="/etc/puma6_helper.sh"
readonly puma_partitions="$proc/avm_partitions"
readonly puma_filesystem_name_active="${filesystem_name}_ATOM"
readonly puma_filesystem_name_inactive="${filesystem_name}_${reserved_prefix}_ATOM"
readonly puma_kernel_name_active="${kernel_name}_ATOM"
readonly puma_kernel_name_inactive="${kernel_name}_${reserved_prefix}_ATOM"
#######################################################################################################
#                                                                                                     #
# sub-functions                                                                                       #
#                                                                                                     #
#######################################################################################################
#                                                                                                     #
# check, if all required commands are present, write missing names to STDERR                          #
# (assume that 'printf' and 'command' are always available as builtins)                               #
#                                                                                                     #
#######################################################################################################
check_required_commands()
{
	error=0
	for cmd in $required_commands; do
		command -v $cmd 2>"$orcus" 1>&2 && continue
		printf "[%s] Missing required command: %s\n" "$project_name" "$cmd" 1>&2
		error=1
	done
	return $error
}
#######################################################################################################
#                                                                                                     #
# (safe) detection of Puma6 and Puma7 devices, only ATOM core supported - runs in a sub-shell         #
#                                                                                                     #
#######################################################################################################
is_puma_based_device()
(
	[ -f "$puma_helper" ] || exit 1
	. "$puma_helper"
	if type is_puma7 2>"$orcus" 1>&2; then
		[ "$IS_ATOM" = "y" ] || exit 1
	else
		is_puma_atom || exit 1
	fi
	exit 0
)
#######################################################################################################
#                                                                                                     #
# check, if the host system has a FDT based environment                                               #
#                                                                                                     #
#######################################################################################################
has_fdt_environment()
{
	[ -d "$fdt_chosen" ] && return 0 || return 1
}
#######################################################################################################
#                                                                                                     #
# check, if the host system supports branding changes via environment writes                          #
#                                                                                                     #
#######################################################################################################
change_branding_support()
{
	has_fdt_environment && return 1
	return 0
}
#######################################################################################################
#                                                                                                     #
# find system type or model name                                                                      #
#                                                                                                     #
#######################################################################################################
get_system_type()
{
	type="$(sed -n -e "s|^system type[ \t]*: \([^ \t]*\).*|\1|p" "$proc_cpuinfo")"
	[ -n "$type" ] && printf "%s\n" "$type" && return 0
	type="$(sed -n -e "$ipq4019_cpuinfo_check" "$proc_cpuinfo")"
	[ -n "$type" ] && printf "%s\n" "$type" && return 0
	printf "%s\n" "undetected"
	return 1
}
#######################################################################################################
#                                                                                                     #
# find partition number with given name                                                               #
#                                                                                                     #
#######################################################################################################
get_mtd_number()
{
	sed -n -e "s|^mtd\([0-9]*\): [^ ]* [^ ]* \"$1\"\$|\1|p" "$proc_mtd"
}
#######################################################################################################
#                                                                                                     #
# GRX5/VR9: locate the MTD partition for kernel or filesystem for the active or alternative system    #
#                                                                                                     #
#######################################################################################################
get_mtd_partition()
(
	[ "$2" = "$active_name" ] || [ "$2" = "$inactive_name" ] || exit 1
	if [ "$1" = "$kernel_name" ] || [ "$1" = "$filesystem_name" ]; then
		eval name="\$mtd_${1}_name_${2}"
		printf "$mtdblock_mask" "$(get_mtd_number "$name")"
		exit 0
	fi
	exit 1
)
#######################################################################################################
#                                                                                                     #
# VR9: locate the MTD partition for kernel or the image name of root filesystem for the active or     #
#      alternative system                                                                             #
#                                                                                                     #
#######################################################################################################
get_vr9_image()
(
	[ "$1" = "$filesystem_name" ] || exit 1
	if [ "$2" = "$active_name" ]; then
		printf "$vr9_image_source_active"
		exit 0
	elif [ "$2" = "$inactive_name" ]; then
		eval name="\$mtd_${1}_name_${2}"
		printf "$vr9_image_source_inactive" "$(printf "$mtdblock_mask" "$(get_mtd_number "$name")")"
		exit 0
	fi
	exit 1
)
#######################################################################################################
#                                                                                                     #
# Puma6/7: locate the eMMC partition for filesystem or kernel of the active or alternative system     #
#                                                                                                     #
#######################################################################################################
get_puma_partition()
(
	[ "$2" = "$active_name" ] || [ "$2" = "$inactive_name" ] || exit 1
	if [ "$1" = "$kernel_name" ] || [ "$1" = "$filesystem_name" ]; then
		eval name="\$puma_${1}_name_${2}"
		sed -n -e "s|^${name}=\(.*\)|\1|p" "$puma_partitions"
		exit 0
	fi
	exit 1
)
#######################################################################################################
#                                                                                                     #
# locate the flash device (MTD or eMMC) for filesystem or kernel of the active or alternative system  #
#                                                                                                     #
#######################################################################################################
get_partition()
(
	rc=0
	[ "$1" = "$kernel_name" ] || [ "$1" = "$filesystem_name" ] || exit 1
	[ "$2" = "$active_name" ] || [ "$2" = "$inactive_name" ] || exit 1
	if is_puma_based_device; then
		get_puma_partition "$1" "$2"
		rc=$?
	else
		st="$(get_system_type)"
		if [ "$st" = "VR9" ] || [ "$st" = "AR10" ]; then
			[ "$1" = "$kernel_name" ] && get_mtd_partition "$1" "$2" || get_vr9_image "$1" "$2"
			rc=$?
		elif [ "$st" = "GRX500" ] || [ "$st" = "GRX350" ] || [ "$st" = "IPQ4019" ]; then
			get_mtd_partition "$1" "$2"
			rc=$?
		else
			rc=1
		fi
	fi
	exit $rc
)
#######################################################################################################
#                                                                                                     #
# get the size of a MTD or eMMC partition                                                             #
#                                                                                                     #
#######################################################################################################
get_partition_size()
(
	if is_puma_based_device; then
		symname="$(sed -n -e "s|\(.*\)=$1|\1|p" "$puma_partitions")"
		size="$(sed -n -e "s|${symname}_SIZE=\(.*\)|\1|p" "$puma_partitions")"
	else
		part="$(expr "$1" : "[^0-9]*\(.*\)")"
		size="$(sed -n -e "s|^mtd${part}: \([^ ]*\) .*|0x\1|p" "$proc_mtd")"
	fi
	[ "${#size}" -gt 2 ] && printf "%d\n" $(( $size )) && exit 0
	exit 1
)
#######################################################################################################
#                                                                                                     #
# check, if a list contains an item and return its index (based on 1)                                 #
#                                                                                                     #
# $1 - the item to look for (needle)                                                                  #
# $2 - the haystack                                                                                   #
#                                                                                                     #
#######################################################################################################
index_of_item()
(
	i=0
	for item in $2; do
		i=$(( i + 1 ))
		[ "$1" = "$item" ] && printf $i && exit 0
	done
	exit 1
)
#######################################################################################################
#                                                                                                     #
# get the count of words in the specified string                                                      #
#                                                                                                     #
# $* - items to count                                                                                 #
#                                                                                                     #
#######################################################################################################
count_of_items()
(
	set -- $*
	printf "%u" $#
)
#######################################################################################################
#                                                                                                     #
# create a locked section using a semaphore file, cleanup older orphaned locks automatically          #
#                                                                                                     #
# $1 - operation (get or release)                                                                     #
# $2 - maximum wait time for 'get'                                                                    #
#                                                                                                     #
#######################################################################################################
spinlock()
(
	( [ "$1" = "get" ] || [ "$1" = "release" ] ) || exit 1
	[ -z "$spinlock_pid" ] && exit 1
	set -C
	if [ "$1" = "get" ]; then
		maxwait=$(( $2 ))
		i=0
		while [ $i -le $maxwait ]; do
			while [ -f "$semafile" ]; do
				pid="$(cat "$semafile")"
				if [ -d "$proc/$pid" ]; then
					sleep 1
					i=$(( i + 1 ))
					[ $i -ge $maxwait ] && exit 1
				else
					if [ -d "$proc" ]; then
						rm "$semafile" 2>"$orcus"
					fi
				fi
			done
			printf "%d" $spinlock_pid >"$semafile"
			pid="$(cat "$semafile")"
			! [ -z $pid ] && [ $pid = $spinlock_pid ] && exit 0
		done
		exit 1
	else
		[ -f "$semafile" ] || exit 0
		pid="$(cat "$semafile")"
		( [ -z $pid ] || [ "$pid" != "$spinlock_pid" ] ) && exit 0
		rm -f "$semafile" 2>"$orcus"
		exit 0
	fi
)
#######################################################################################################
#                                                                                                     #
# compare two strings and return -1, 0 or 1 for lower, equal and higher                               #
#                                                                                                     #
# $1 - left item to compare                                                                           #
# $2 - right item to compare                                                                          #
#                                                                                                     #
#######################################################################################################
compare_strings()
(
	t="$tempdir/cs_$$"
	while [ -d "$t" ]; do
		t="$t_$$"
	done
	mkdir -p "$t" 2>"$orcus"
	trap "rm -r \"$t\" 2>\"$orcus\"" EXIT HUP INT
	printf "%s\377" "$1" >"$t/left"
	printf "%s\377" "$2" >"$t/right"
	cmp -l "$t/left" "$t/right" 2>"$orcus" >"$t/out"
	read pos left right 2>"$orcus" <"$t/out"
	if [ -z "$left" ] || [ -z "$right" ]; then
		printf "0"
	else
		[ $left -lt $right ] && printf "-1" || printf "1"
	fi
)
#######################################################################################################
#                                                                                                     #
# get branding of running system                                                                      #
#                                                                                                     #
#######################################################################################################
get_system_branding()
(
	fixed="$(get_fixed_branding)" && printf "%s" "$fixed" && exit 0
	sed -n -e "s/^$branding_name\t\(.*\)\$/\1/p" "$urlader_environment"
)
#######################################################################################################
#                                                                                                     #
# get next system to boot from environment                                                            #
#                                                                                                     #
#######################################################################################################
get_system_switch()
(
	[ -n "$2" ] && sed -n -e "s/^$system_select_name\t[01]\(.*\)\$/\1/p" "$1" && return
	v=$(sed -n -e "s/^$system_select_name\t\([01]\).*\$/\1/p" "${1:-$urlader_environment}")
	[ -z "$v" ] && v=0
	printf "%u\n" "$v"
)
#######################################################################################################
#                                                                                                     #
# check, whether the specified YAFFS2 partition contains data                                         #
#                                                                                                     #
# $1 - (block) device to check, with wrapper info surrounded                                          #
#                                                                                                     #
#######################################################################################################
is_wrapper_partition_empty()
(
	part="${1#$wrapper_mount_prefix}"
	part="${part%%:*}"
	is_partition_empty "$part" && exit 0
)
#######################################################################################################
#                                                                                                     #
# check the first 256 byte of the specified partition - if they're all 0xFF or 0x00, there's usually  #
# no content (and no complete alternative system installed )                                          #
#                                                                                                     #
# $1 - (block) device to check                                                                        #
#                                                                                                     #
#######################################################################################################
is_partition_empty()
(
	__read_bytes()
	{
		while read line left right; do
			[ $left -ne 377 ] && [ $left -ne 0 ] && return 1
		done
		return 0
	}
	if [ "${1#$wrapper_mount_prefix}" = "$1" ]; then
		dd if="$1" bs=256 count=1 2>"$orcus" | cmp -l - "$dev/zero" 2>"$orcus" | __read_bytes
	else
		is_wrapper_partition_empty "$1"
	fi
)
#######################################################################################################
#                                                                                                     #
# check, if the system to start next is also the running one                                          #
#                                                                                                     #
# - if a FDT exists, the started system may be found there                                            #
# - if a saved environment exists, we take the value from there and treat it as the original one      #
# - if neither of the places above contains a valid value, the partition of 'kernel' type with the    #
#   lowest device index is assumed to be from system selector value 0                                 #
#                                                                                                     #
#######################################################################################################
is_switched()
(
	if [ -d "$fdt_chosen" ]; then
		! [ "$(cat "$fdt_chosen/$system_select_name" | sed -n -e "s|^\([01]\).*|\1|p")" = "$(get_system_switch)" ]
	else
		if [ -f "$boot_cache_file" ]; then
			! [ "$(get_system_switch)" = "$(get_system_switch "$boot_cache_file")" ]
		else
			k1="$(get_partition "$kernel_name" "$active_name")"
			k2="$(get_partition "$kernel_name" "$inactive_name")"
			c=$(compare_strings "$k1" "$k2")
			[ $c -eq -1 ] && current=0 || current=1
			! [ "$(get_system_switch)" = "$current" ]
		fi
	fi
)
#######################################################################################################
#                                                                                                     #
# switch system selection variable to alternative value                                               #
#                                                                                                     #
#######################################################################################################
switch_system()
(
	printf '%s\t%d%s\n' "$system_select_name" $(( ( $(get_system_switch) + 1 ) % 2 )) "$(get_system_switch "$urlader_environment" 1)" >"$urlader_environment"
)
#######################################################################################################
#                                                                                                     #
# switch next boot time selection to specified system, if action is really needed                     #
#                                                                                                     #
# $1 - 'running' / 'alternative' to switch to the specified system based on the running version       #
#                                                                                                     #
#######################################################################################################
switch_system_to()
(
	if is_switched; then
		[ "$1" = "running" ] && switch_system
	else
		[ "$1" = "alternative" ] && switch_system
	fi
	[ -z "$2" ] || change_branding "$2"
)
#######################################################################################################
#                                                                                                     #
# replace branding, if necessary                                                                      #
#                                                                                                     #
#######################################################################################################
change_branding()
(
	[ "$1" = "$(get_system_branding)" ] || printf '%s\t%s' "$branding_name" "$1" >"$urlader_environment"
)
#######################################################################################################
#                                                                                                     #
# get product name value from AVM's rc.conf file                                                      #
#                                                                                                     #
# $1 - system root directory                                                                          #
#                                                                                                     #
#######################################################################################################
get_product_name()
(
	sed -n -e "s|^[ \t]*export $avm_product_name=\"\?\([^\"]*\)\"\?\$|\1|p" "${1:-/}${1:+/}$avm_version_file" | sed -n -e \$p
)
#######################################################################################################
#                                                                                                     #
# get major version from AVM's rc.conf file                                                           #
#                                                                                                     #
# $1 - system root directory                                                                          #
#                                                                                                     #
#######################################################################################################
get_version_major()
(
	sed -n -e "s|^[ \t]*export $avm_version_major_name=\"\?\([^\"]*\)\"\?\$|\1|p" "${1:-/}${1:+/}$avm_version_file" | sed -n -e \$p
)
#######################################################################################################
#                                                                                                     #
# get the contained brandings from the directory with system defaults                                 #
#                                                                                                     #
# $1 - system root directory                                                                          #
#                                                                                                     #
#######################################################################################################
get_brandings()
(
	fixed="$(get_fixed_branding "$1")" && printf "%s" "$fixed" && exit 0
	if [ -z "$1" ] || [ "$1" = "/" ]; then
		eval PRODUKT="\$$avm_product_name"
	else
		PRODUKT="$(get_product_name "$1")"
	fi
	eval path="${1:-/}${1:+/}$defaults_dir"
	first=0
	for dir in $path/*; do
		[ $first -ne 0 ] && printf " " || first=1
		printf "%s" "${dir#$path/}"
	done
	printf "\n"
)
#######################################################################################################
#                                                                                                     #
# extract firmware variables from AVM's firmware info source                                          #
#                                                                                                     #
# $1 - info source file                                                                               #
# $2 - values prefix in this file                                                                     #
#                                                                                                     #
#######################################################################################################
get_version_main_values()
(
	for v in $avm_version_main_components; do
		sed -n -e "s|^[ \t]*export $2$v=\"\?\([^\"]*\)\"\?\$|$v=\"\1\"|p" "$1" | sed -n -e \$p
	done
)
#######################################################################################################
#                                                                                                     #
# extract firmware variables from AVM's firmware new info source                                      #
#                                                                                                     #
# $1 - system root directory                                                                          #
#                                                                                                     #
#######################################################################################################
get_new_version_main_values()
(
	path="${1:-/}${1:+/}$avm_version_file"
	prefix="$avm_version_file_prefix"
	get_version_main_values "$path" "$prefix"
)
#######################################################################################################
#                                                                                                     #
# extract firmware variables from AVM's firmware old info source                                      #
#                                                                                                     #
# $1 - system root directory                                                                          #
#                                                                                                     #
#######################################################################################################
get_old_version_main_values()
(
	path="${1:-/}${1:+/}$avm_version_file_old"
	prefix="$avm_version_file_old_prefix"
	get_version_main_values "$path" "$prefix"
)
#######################################################################################################
#                                                                                                     #
# check, if version info is specified in the older or newer place                                     #
#                                                                                                     #
# $1 - system root directory                                                                          #
#                                                                                                     #
#######################################################################################################
has_old_version_info()
(
	path="${1:-/}${1:+/}$avm_version_file_old"
	set -- $avm_version_main_components
	[ -z "$(sed -n -e "s|^[ \t]*export $avm_version_file_old_prefix$1=\"\?\([^\"]*\)\"\?\$|\1|p" "$path")" ] \
		&& exit 1 || exit 0
)
#######################################################################################################
#                                                                                                     #
# get system version from specified system root                                                       #
#                                                                                                     #
# $1 - system root directory                                                                          #
#                                                                                                     #
#######################################################################################################
get_version_values()
(
	if has_old_version_info "$1"; then
		get_old_version_main_values "$1"
	else
		get_new_version_main_values "$1"
	fi
)
#######################################################################################################
#                                                                                                     #
# get system version from specified system root                                                       #
#                                                                                                     #
# $1 - system root directory                                                                          #
#                                                                                                     #
#######################################################################################################
get_system_version()
(
	eval $(get_version_values "$1")
	has_old_version_info "$1" && printf '%s%s' "$VERSION" "$SUBVERSION" || printf '%s.%s%s' "$(get_version_major "$1")" "$VERSION" "$SUBVERSION"
)
#######################################################################################################
#                                                                                                     #
# parse date value with format from AVM's firmware (/etc/version) to a UNIX timestamp                 #
#                                                                                                     #
# $1 - source string                                                                                  #
#                                                                                                     #
#######################################################################################################
parse_date_value()
(
	command -v date 2>"$orcus" 1>&2 || printf "%s" "$1"
	date --help 2>&1 | grep -q BusyBox || printf "%s" "$1"
	eval $(printf "%s\n" "$1" | sed -n -e "s|\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\) \([0-9]*\):\([0-9]*\):\([0-9]*\)|DAY=\1 MONTH=\2 YEAR=\3 HOUR=\4 MINUTES=\5 SECONDS=\6|p")
	date +%s -d $YEAR$MONTH$DAY$HOUR$MINUTES.$SECONDS
)
#######################################################################################################
#                                                                                                     #
# get localized date string                                                                           #
#                                                                                                     #
#######################################################################################################
get_localized_date()
{
	[ "$Language" = "de" ] && date +"%d.%m.%Y, %H:%M:%S Uhr" -d @$1 || date +"%m/%d/%Y %r" -d @$1
}
#######################################################################################################
#                                                                                                     #
# get system build date from specified root, it's a file modification time in the newer versions      #
#                                                                                                     #
# $1 - system root directory                                                                          #
#                                                                                                     #
#######################################################################################################
get_system_date()
(
	path="${1:-/}${1:+/}$avm_version_file_old"
	if has_old_version_info "$1"; then
		d="$(sed -n -e "s|^[ \t]*export $avm_version_file_old_prefix$avm_version_date=\"\?\([^\"]*\)\"\?\$|\1|p" "$path")"
		v=$(parse_date_value "$d")
	else
		v=$(stat -c %Y "$path")
	fi
	printf '%d' "$v"
)
#######################################################################################################
#                                                                                                     #
# get system build date from specified root as a string value with localization                       #
#                                                                                                     #
# $1 - system root directory                                                                          #
#                                                                                                     #
#######################################################################################################
get_localized_system_date()
(
	get_localized_date "$(get_system_date "$1")"
)
#######################################################################################################
#                                                                                                     #
# get fixed brandings string from specified system root                                               #
#                                                                                                     #
# $1 - system root directory                                                                          #
#                                                                                                     #
#######################################################################################################
get_fixed_branding()
(
	path="${1:-/}${1:+/}$avm_rcconf"
	b="$(sed -n -e 's|^export OEM\(=\"\?\(.*\)\"\?\)\?$|\2|p' "$path")"
	printf "%s" "$b"
	[ -z "$b" ] && exit 1 || exit 0
)
#######################################################################################################
#                                                                                                     #
# check, if the specified directory is an active mount-point for any filesystem                       #
#                                                                                                     #
#######################################################################################################
is_active_mountpoint()
(
	line="$(sed -n -e "\|^[0-9]\+ [0-9]\+ [0-9:]* [^ ]* ${1:-/} .* - .*|p" "$proc_mountinfo")"
	[ ${#line} -eq 0 ] && exit 1 || exit 0
)
#######################################################################################################
#                                                                                                     #
# find an active mountpoint with the specified device                                                 #
#                                                                                                     #
#######################################################################################################
find_mountpoint_for_device()
(
	line="$(sed -n -e "s|^[0-9]\+ [0-9]\+ [0-9:]* [^ ]* \(.*\) .* - [^ ]* $1 .*|\1|p" "$proc_mountinfo")"
	[ ${#line} -eq 0 ] || printf "%s" "$line"
	[ ${#line} -eq 0 ] && exit 1 || exit 0
)
#######################################################################################################
#                                                                                                     #
# find the device for an active mountpoint                                                            #
#                                                                                                     #
#######################################################################################################
find_device_of_mountpoint()
(
	line="$(sed -n -e "s|^[0-9]\+ [0-9]\+ [0-9:]* [^ ]* $1 .* - [^ ]* \([^ ]*\) .*|\1|p" "$proc_mountinfo")"
	[ ${#line} -eq 0 ] || printf "%s" "$line"
	[ ${#line} -eq 0 ] && exit 1 || exit 0
)
#######################################################################################################
#                                                                                                     #
# check, if the specified mountpoint is from a loop device                                            #
#                                                                                                     #
#######################################################################################################
get_ids_of_mountpoint()
(
	line="$(sed -n -e "s|^[0-9]\+ [0-9]\+ *\([0-9]*:[0-9]*\) [^ ]* ${1:-/} .* - [^ ]* \([^ ]*\) .*|\1|p" "$proc_mountinfo")"
	[ ${#line} -eq 0 ] || printf "%s" "$line"
	[ ${#line} -eq 0 ] && exit 1 || exit 0
)
#######################################################################################################
#                                                                                                     #
# check, if the specified mountpoint is from a loop device                                            #
#                                                                                                     #
#######################################################################################################
is_loopdevice_mountpoint()
(
	loop_major="$(sed -n -e "s|^ *\([0-9]*\) *$loop_driver_name[ \t]\?.*\$|\1|p" "$proc_devices")"
	[ ${#loop_major} -eq 0 ] && exit 1
	device="$(get_ids_of_mountpoint "$1")"
	[ ${#device} -eq 0 ] && exit 1
	[ "${device%:*}" = "$loop_major" ] && exit 0 || exit 1
)
#######################################################################################################
#                                                                                                     #
# get file name of mounted image for a loopback device                                                #
#                                                                                                     #
#######################################################################################################
get_loopdevice_backingfile()
(
	if is_loopdevice_mountpoint "${1:-/}"; then
		devid="$(get_ids_of_mountpoint "${1:-/}")"
		[ -z "$devid" ] && exit 1
		for device in "$sysfs_block_dir"/*; do
			if [ "$(cat "$device/dev" 2>"$orcus")" = "$devid" ]; then
				file="$(cat "$device/$loop_driver_name/$backing_file_name" 2>"$orcus")"
				[ "${#file}" -gt 0 ] && printf "%s\n" "$file" && exit 0
			fi
		done
	fi
	exit 1
)
#######################################################################################################
#                                                                                                     #
# mount alternative system' root filesystem somewhere                                                 #
#                                                                                                     #
#######################################################################################################
mount_alternative_system()
(
	src="$(get_partition "$filesystem_name" "$inactive_name")"
	mp="$tempdir/$alt_root_mount_name"
	mkdir -p "$mp" 2>"$orcus" || exit 1
	if ! [ "${src#mount:}" = "$src" ]; then
		set -- $(printf "%s" "$src" | sed -e "s|:| |g")
		device="$2"
		file="$3"
	else
		unset device
		file="$src"
	fi
	if ! [ -z "$device" ]; then
		wr="$tempdir/$wrapper_mount_name"
		mkdir -p "$wr" 2>"$orcus" || exit 1
		wre="$(find_mountpoint_for_device "$device")"
		if [ $? -ne 0 ]; then
			mount -t yaffs2 -o ro "$device" "$wr" 2>"$orcus" || exit 1
		else
			wr="$wre"
		fi
	fi
	mount -t squashfs -o ro "$wr$file" "$mp" 2>"$orcus" || exit 1
	printf "%s" "$mp"
	exit 0
)
#######################################################################################################
#                                                                                                     #
# dismount the alternative root filesystem                                                            #
#                                                                                                     #
#######################################################################################################
dismount_alternative_system()
(
	is_active_mountpoint "$tempdir/$alt_root_mount_name" || exit 0
	umount -d "$tempdir/$alt_root_mount_name" 2>"$orcus" || exit 1
	rmdir "$tempdir/$alt_root_mount_name" 2>"$orcus"
	is_active_mountpoint "$tempdir/$wrapper_mount_name" || exit 0
	umount -d "$tempdir/$wrapper_mount_name" 2>"$orcus" || exit 1
	rmdir "$tempdir/$wrapper_mount_name" 2>"$orcus"
	exit 0
)
#######################################################################################################
#                                                                                                     #
# guess modification source                                                                           #
#                                                                                                     #
# $1 - mounted system root directory (optional)                                                       #
#                                                                                                     #
#######################################################################################################
get_modified_by()
(
	base="${1:-/}"
	[ "${base%/}" = "$base" ] && base="$base/"
	i=1
	for f in $version_files; do
		path="$(eval printf "%s%s" "$base" $f)"
		[ -f "$path" ] && break
		i=$(( i + 1 ))
	done
	set -- $modified_by
	eval printf -- "%s" "\$$i"
)
#######################################################################################################
#                                                                                                     #
# convert binary value (from STDIN) to decimal representation                                         #
#                                                                                                     #
#######################################################################################################
bin2dec()
(
	bin2dec_read_octal()
	{
		e=$1
		i=1
		l=0
		v=0
		s=-8
		ff=0
		while read pos left right; do
			if [ $ff -eq 1 ]; then
				[ $e -eq 0 ] && v=$(( v * 256 )) || s=$(( s + 8 ))
				[ $e -eq 0 ] && ff=255 || ff=$(( 255 << s ))
				v=$(( v + ff ))
				i=$(( i + 1 ))
				ff=0
			fi
			while [ $i -lt $pos ]; do # insert zeros for missing bytes
				[ $e -eq 0 ] && v=$(( v * 256 )) || s=$(( s + 8 ))
				i=$(( i + 1 ))
			done
			if [ $right = 377 ] && [ $ff -eq 0 ]; then
				ff=1
				continue
			fi
			[ $e -eq 0 ] && v=$(( v * 256 )) || s=$(( s + 8 ))
			[ $e -eq 0 ] && right=$(( 0$right )) || right=$(( 0$right << s ))
			v=$(( v + right ))
			i=$(( pos + 1 ))
		done
		printf "%d" $v
	}

	[ $(dd if="$proc/self/exe" bs=1 count=1 skip=5 2>"$orcus" | base64) = AQ== ] && e=1 || e=0
	( cat; printf "%b" "\377" ) | cmp -l -- "$dev/zero" - 2>"$orcus" | bin2dec_read_octal $e
	return 0
)
#######################################################################################################
#                                                                                                     #
# get mkfs_time value from SquashFS superblock                                                        #
#                                                                                                     #
# $1 - mounted system root directory                                                                  #
#                                                                                                     #
#######################################################################################################
get_mkfs_time()
(
	base="${1:-}"
	if is_loopdevice_mountpoint "${base:-/}"; then
		src="$(get_loopdevice_backingfile "${base:-/}")"
		[ "${#src}" -gt 0 ] && len=$(stat -c %s "$src") || len=0
	elif [ -z "$1" ] || [ "$1" = "/" ]; then	# root of running system needs /proc/mtd
		src="$(get_partition "$filesystem_name" "$active_name")"
		[ "${#src}" -gt 0 ] && len=$(get_partition_size "$src") || len=0
	else
		src="$(find_device_of_mountpoint "$1")"
		[ "${#src}" -gt 0 ] && len=$(get_partition_size "$src") || len=0
	fi
	if [ "${#src}" -gt 0 ]; then
		v="$(dd if="$src" bs=4 count=1 skip=2 2>"$orcus" | bin2dec)"
		if [ "${#v}" -gt 0 ]; then
			if [ "$v" -gt "$len" ]; then
				printf "%s\n" "$v" && exit 0
			fi
		fi
	fi
	exit 1
)
#######################################################################################################
#                                                                                                     #
# get date of last modification from specified system root                                            #
# - take the date and time from any existing modification file or                                     #
# - take date and time from SquashFS image, if it's a file (mounted via a loop device)                #
#                                                                                                     #
#                                                                                                     #
# $1 - mounted system root directory (optional)                                                       #
#                                                                                                     #
#######################################################################################################
get_modified_date()
(
	command -v stat 2>"$orcus" 1>&2 || exit 1
	v="$(stat -c %Y -- "$proc/self/exe" 2>"$orcus")"
	[ $? -ne 0 ] && exit 1
	[ "$(expr "$v" : "\([0-9]*\)")" = "$v" ] || exit 1
	base="${1:-}"
	unset v
	for f in $version_files; do
		[ -z "$base" ] && b="/" || b="$base"
		[ "${b%/}" = "$b" ] && b="$b/"
		path="$(eval printf "%s%s" "$b" $f)"
		if [ -f "$path" ]; then
			v="$(stat -c %Y -- "$path")"
			break
		fi
	done
	if [ -z "$v" ]; then
		v="$(get_mkfs_time "${base:-/}")"	# try to find valid mkfs_time first
	fi
	if [ -z "$v" ] && is_loopdevice_mountpoint "${base:-/}"; then
		file="$(get_loopdevice_backingfile "${base:-/}")"
		v="$(stat -c %Y -- "$file")"
		d="$(get_system_date "$1")"
		if [ -n "$d" ] && [ -n "$v" ]; then
			[ $d -lt $v ] && delta=$(( v - d )) || delta=$(( d - v ))	# no abs() function available
			[ $delta -lt 600 ] && exit 1 	# within ten minutes, assume no further modifications
		fi
	fi
	[ -z "$v" ] && exit 1
	get_localized_date "$v"
	exit 0
)
#######################################################################################################
#                                                                                                     #
# cleanup any mounted images and remove the temporary directory and semaphore file, if it's owned by  #
# this instance to avoid deadlocks                                                                    #
#                                                                                                     #
#######################################################################################################
cleanup()
{
	[ -z "$tempdir" ] && return
	is_active_mountpoint "$tempdir/$alt_root_mount_name" && umount -d "$tempdir/$alt_root_mount_name" 2>"$orcus"
	is_active_mountpoint "$tempdir/$wrapper_mount_name" && umount -d "$tempdir/$wrapper_mount_name" 2>"$orcus"
	rm -r "$tempdir" 2>"$orcus"
	[ -z "$spinlock_pid" ] && return
	[ -f "$semafile" ] || return
	[ "$(cat $semafile 2>"$orcus")" = "$spinlock_pid" ] && rm -f "$semafile" 2>"$orcus"
}
#######################################################################################################
#                                                                                                     #
# check dual-boot support                                                                             #
#                                                                                                     #
#######################################################################################################
is_dualboot_supported()
(
	[ -z "$(get_partition "$kernel_name" "$inactive_name")" ] && exit 1
	[ -z "$(get_partition "$filesystem_name" "$inactive_name")" ] && exit 1
	[ -z "$(get_system_switch)" ] && exit 1
	exit 0
)
#######################################################################################################
#                                                                                                     #
# collect data for running system and alternative partitions                                          #
#                                                                                                     #
#######################################################################################################
collect_data()
{
	readonly running_version="$(get_system_version)"
	readonly running_date="$(get_localized_system_date)"
	readonly running_fsdate="$(get_modified_date)"
	readonly running_modified="$(get_modified_by)"
	chg_running_branding=0
	running_branding_fixed=0
	readonly current_branding="$(get_system_branding)"
	readonly running_brandings="$(get_brandings)"
	[ -z "$(get_fixed_branding)" ] || running_branding_fixed=1
	[ $(count_of_items "$running_brandings") -gt 1 ] && chg_running_branding=1
	readonly current_system_switch=$(get_system_switch)
	alternative_is_missing=1
	chg_alternative_branding=0
	alternative_branding_fixed=0
	is_partition_empty "$(get_partition "$kernel_name" "$inactive_name")" && nokernel=1 || nokernel=0
	is_partition_empty "$(get_partition "$filesystem_name" "$inactive_name")" && nofs=1 || nofs=0
	if [ $nokernel -eq 0 ] && [ $nofs -eq 0 ]; then
		alternative_is_missing=0
		spinlock get 10 && mp="$(printf "%s" "$(mount_alternative_system)")"
		if ! [ -z "$mp" ]; then
			readonly alternative_version="$(get_system_version "$mp")"
			if ! [ -z "$alternative_version" ]; then
				readonly alternative_date="$(get_localized_system_date "$mp")"
				readonly alternative_fsdate="$(get_modified_date "$mp")"
				readonly alternative_modified="$(get_modified_by "$mp")"
				readonly alternative_brandings="$(get_brandings "$mp")"
				[ -z "$(get_fixed_branding "$mp")" ] && alternative_branding_fixed=0 || alternative_branding_fixed=1
				[ $(count_of_items "$alternative_brandings") -gt 1 ] && chg_alternative_branding=1
			fi
			dismount_alternative_system
		fi
		spinlock release
	fi
}
#######################################################################################################
#                                                                                                     #
# gather information regarding the two systems                                                        #
#                                                                                                     #
#######################################################################################################
get_values()
{
	printf "active_version=\"%s\"\n" "$running_version"
	printf "active_date=\"%s\"\n" "$running_date"
	printf "active_modified_by=\"%s\"\n" "$running_modified"
	printf "active_modified_at=\"%s\"\n" "$running_fsdate"
	printf "active_brandings=\"%s\"\n" "$running_brandings"
	if [ $alternative_is_missing -eq 1 ]; then
		printf "inactive_version=\"%s\"\n" "missing"
	else
		printf "inactive_version=\"%s\"\n" "$alternative_version"
		printf "inactive_date=\"%s\"\n" "$alternative_date"
		printf "inactive_modified_by=\"%s\"\n" "$alternative_modified"
		printf "inactive_modified_at=\"%s\"\n" "$alternative_fsdate"
		printf "inactive_brandings=\"%s\"\n" "$alternative_brandings"
	fi
	printf "current_branding=\"%s\"\n" "$current_branding"
	cb_support=$(( alternative_branding_fixed + running_branding_fixed ))
	if [ $cb_support -eq 2 ]; then
		cb_supported="both_fixed"
	else
		if change_branding_support; then
			if [ $cb_support -eq 1 ]; then
				if [ $running_branding_fixed -eq 1 ]; then
					cb_supported="running_fixed"
				else
					cb_supported="alternative_fixed"
				fi
			else
				cb_supported="true"
			fi
		else
			cb_supported="false"
		fi
	fi
	printf "switch_branding_support=%s\n" "$cb_supported"
	printf "current_switch_value=%s\n" "$current_system_switch"
	printf "system_is_switched=%s\n" $(is_switched && printf "true" || printf "false")
}
#######################################################################################################
#                                                                                                     #
# save initial environment at first call                                                              #
#                                                                                                     #
#######################################################################################################
save_environment()
(
	[ -f "$boot_cache_file" ] || cat "$urlader_environment" > "$boot_cache_file" 2>"$orcus"
)
#######################################################################################################
#                                                                                                     #
# prepare a temporary directory and a clean exit routine                                              #
#                                                                                                     #
#######################################################################################################
export PATH="$search_path"
check_required_commands || exit 126 # missing required commands, look on STDERR in case of an error
exec 2>&1                           # error messages on STDOUT now
readonly tempdir="$tmpdir/$$_$(date +%s)"
mkdir -p "$tempdir" 2>"$orcus"
trap cleanup HUP EXIT INT TERM
rc=127
#######################################################################################################
#                                                                                                     #
# check parameters and call requested function                                                        #
#                                                                                                     #
#######################################################################################################
case "$1" in
	("is_supported")
		is_dualboot_supported && rc=0 || rc=1
		;;
	("is_blocked")
		[ -f $semafile ] && rc=1 || rc=0
		;;
	("debug")
		is_puma_based_device && printf "system type = Puma6/7\n" || printf "system type = %s\n" "$(get_system_type)"
		printf "system selector = %u\n" "$(get_system_switch)"
		printf "system is switched = %s\n" "$(is_switched && printf "true" || printf "false")"
		printf "system branding = %s\n" "$(get_system_branding)"
		printf "system branding is changeable = %s\n" "$(change_branding_support && printf "true" || printf "false")"
		printf "active kernel = %s\n" "$(get_partition "$kernel_name" "$active_name")"
		printf "active filesystem = %s\n" "$(get_partition "$filesystem_name" "$active_name")"
		printf "active system version = %s\n" "$(get_system_version)"
		printf "active system date = %s\n" "$(get_localized_system_date)"
		printf "active system modification date = %s\n" "$(get_modified_date)"
		printf "active system modification source = %s\n" "$(get_modified_by)"
		printf "brandings supported on active system = %s%s\n" "$(get_brandings)" "$([ -z "$(get_fixed_branding)" ] || printf " (fixed)")"
		is_partition_empty "$(get_partition "$kernel_name" "$inactive_name")" && nokernel=1 || nokernel=0
		is_partition_empty "$(get_partition "$filesystem_name" "$inactive_name")" && nofs=1 || nofs=0
		printf "inactive kernel = %s\n" "$(get_partition "$kernel_name" "$inactive_name")"
		printf "inactive filesystem = %s\n" "$(get_partition "$filesystem_name" "$inactive_name")"
		if [ $nokernel -eq 0 ] && [ $nofs -eq 0 ]; then
			spinlock_pid=$$
			spinlock get 10 && mp="$(printf "%s" "$(mount_alternative_system)")"
			printf "inactive filesystem mounted on %s\n" "$mp"
			if ! [ -z "$mp" ]; then
				printf "inactive system version = %s\n" "$(get_system_version "$mp")"
				printf "inactive system date = %s\n" "$(get_localized_system_date "$mp")"
				mod_date="$(get_modified_date "$mp")"
				[ -z "$mod_date" ] && mod_date="undetected"
				printf "inactive system modification date = %s\n" "$mod_date"
				printf "inactive system modification source = %s\n" "$(get_modified_by "$mp")"
				printf "brandings supported on inactive system = %s%s\n" "$(get_brandings "$mp")" "$([ -z "$(get_fixed_branding "$mp")" ] || printf " (fixed)")"
				dismount_alternative_system
				printf "inactive filesystem dismounted\n"
			else
				printf "inactive filesystem could not be mounted\n"
			fi
			spinlock release
		else
			printf "inactive system checks skipped due to "
			[ $nokernel -eq 1 ] && printf "inactive kernel partition is empty "
			[ $nokernel -eq 1 ] && [ $nofs -eq 1 ] && printf "and "
			[ $nofs -eq 1 ] && printf "inactive filesystem partition is empty"
			[ $nokernel -eq 1 ] && [ $nofs -eq 1 ] && printf ", too"
			printf "\n"
		fi
		rc=0
		;;
	("get_values")
		if is_dualboot_supported; then
			if [ "$2" = "nocache" ] || ! [ -f "$data_cache_file" ]; then
				spinlock_pid=$$
				collect_data
				[ "$2" = "nocache" ] && get_values ||  get_values >"$data_cache_file"
			fi
			[ "$2" = "nocache" ] || cat "$data_cache_file" 2>"$orcus"
			rc=0
			save_environment
		else
			rc=1
		fi
		;;
	("clear_cache")
		[ -f "$data_cache_file" ] && rm "$data_cache_file" 2>"$orcus"
		rc=0
		;;
	("switch_to")
		if is_dualboot_supported; then
			switch_system_to $2 $3
			rc=$?
		else
			rc=1
		fi
		;;
	("*")
		printf "Unknown operation '%s'.\n" "$1" 1>&2
		rc=1
		;;
esac
#######################################################################################################
#                                                                                                     #
# finish and regular exit                                                                             #
#                                                                                                     #
#######################################################################################################
exit $rc
#######################################################################################################
#                                                                                                     #
# end of script                                                                                       #
#                                                                                                     #
#######################################################################################################)
